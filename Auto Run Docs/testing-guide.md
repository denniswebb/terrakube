# Terrakube Testing Guide

This guide provides comprehensive information on running, writing, and understanding tests in the Terrakube project. It covers both frontend (React/TypeScript) and backend (Java/Spring Boot) testing infrastructure.

## Table of Contents
- [Quick Start](#quick-start)
- [Frontend Testing](#frontend-testing)
- [Backend Testing](#backend-testing)
- [Integration Testing](#integration-testing)
- [API Testing](#api-testing)
- [CI/CD Testing](#cicd-testing)
- [Quality Gates](#quality-gates)
- [Writing New Tests](#writing-new-tests)
- [Best Practices](#best-practices)

---

## Quick Start

### Run All Tests

**Frontend:**
```bash
cd ui
npm test -- --watchAll=false
```

**Backend:**
```bash
# From project root
mvn test

# Or using mise (recommended)
mise exec -- mvn test
```

### Run Tests with Coverage

**Frontend:**
```bash
cd ui
npm test -- --coverage --watchAll=false
```

**Backend:**
```bash
mvn verify
# Coverage reports generated by JaCoCo plugin
```

---

## Frontend Testing

### Testing Stack
- **Test Framework:** Jest 30.2.0
- **Test Library:** @testing-library/react 16.3.1
- **DOM Matchers:** @testing-library/jest-dom 6.9.1
- **Environment:** jsdom (browser DOM simulation)
- **TypeScript:** ts-jest transformer

### Configuration Files
- `ui/jest.config.js` - Main Jest configuration
- `ui/jest.setup.ts` - Test environment setup
- `ui/tsconfig.test.json` - TypeScript configuration for tests

### Running Frontend Tests

```bash
cd ui

# Run all tests
npm test -- --watchAll=false

# Run with coverage
npm test -- --coverage --watchAll=false

# Run specific test file
npm test -- formatSshUrl.spec.ts --watchAll=false

# Run in watch mode (for development)
npm test
```

### Frontend Test Patterns

**File Naming Convention:**
- Test files use `.spec.ts` or `.spec.tsx` extension
- Co-located with source files (e.g., `formatSshUrl.ts` â†’ `formatSshUrl.spec.ts`)

**Test Structure Example:**
```typescript
import { formatSshUrl } from './formatSshUrl';

describe('formatSshUrl', () => {
  test('should format GitHub SSH URL correctly', () => {
    const input = 'git@github.com:user/repo.git';
    const result = formatSshUrl(input);
    expect(result).toBe('ssh://git@github.com/user/repo.git');
  });

  test('should handle edge case X', () => {
    // Test edge case
  });
});
```

**Key Patterns:**
- `describe()` blocks group related tests
- `test()` or `it()` for individual test cases
- `expect()` assertions with Jest matchers
- Descriptive test names following pattern: "[Feature/Provider] [action] [expected result]"

### Component Testing

**Testing React Components:**
```typescript
import { render, screen } from '@testing-library/react';
import { MyComponent } from './MyComponent';

describe('MyComponent', () => {
  test('renders correctly with props', () => {
    render(<MyComponent title="Test" />);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  test('handles user interaction', async () => {
    const handleClick = jest.fn();
    render(<MyComponent onClick={handleClick} />);

    const button = screen.getByRole('button');
    await userEvent.click(button);

    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### Current Coverage Metrics
- **Statements:** 98.96%
- **Branches:** 97.61%
- **Functions:** 100%
- **Lines:** 98.91%

---

## Backend Testing

### Testing Stack
- **Framework:** JUnit 5 (Jupiter)
- **Mocking:** Mockito (included in spring-boot-starter-test)
- **Assertions:** AssertJ fluent assertions
- **Spring Testing:** spring-boot-starter-test, spring-security-test
- **API Testing:** REST Assured 5.5.6
- **HTTP Mocking:** WireMock Spring Boot 4.0.8
- **Test Database:** H2 in-memory database
- **Coverage:** JaCoCo Maven Plugin 0.8.14

### Running Backend Tests

```bash
# From project root - run all tests
mvn test

# Run with coverage (verify phase includes tests)
mvn verify

# Run tests for specific module
mvn test -pl api

# Skip tests (not recommended)
mvn install -Dmaven.test.skip=true

# Using mise (recommended if configured)
mise exec -- mvn test
```

### Backend Test Types

#### 1. Unit Tests
Pure unit tests with mocked dependencies, focusing on business logic isolation.

**Location:** `api/src/test/java/org/terrakube/api/plugin/scheduler/`

**Example Structure:**
```java
@ExtendWith(MockitoExtension.class)
class ScheduleJobTest {

    @Mock
    private JobRepository jobRepository;

    @Mock
    private ExecutorService executorService;

    private ScheduleJob scheduleJob;

    @BeforeEach
    void setup() {
        scheduleJob = new ScheduleJob(jobRepository, executorService);
    }

    @Test
    void expiredJobsAreDescheduled() {
        // Arrange
        Job expiredJob = createExpiredJob();
        doReturn(List.of(expiredJob)).when(jobRepository).findAll();

        // Act
        scheduleJob.processExpiredJobs();

        // Assert
        verify(executorService, times(1)).cancelJob(expiredJob.getId());
    }
}
```

**Key Patterns:**
- Use `@ExtendWith(MockitoExtension.class)` for Mockito support
- `@Mock` for dependency injection
- `@BeforeEach setup()` for test initialization
- Arrange-Act-Assert structure
- `verify()` for interaction verification
- Custom `FailUnknownMethod` helper ensures strict mocking

#### 2. Configuration Tests
Tests for Spring Boot configuration and property binding.

**Example:**
```java
class StreamingPropertiesTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(StreamingConfiguration.class))
        .withPropertyValues(
            "org.terrakube.api.streaming.type=SSE",
            "org.terrakube.api.streaming.interval=5000"
        );

    @Test
    void shouldBindPropertiesCorrectly() {
        contextRunner.run(context -> {
            StreamingProperties props = context.getBean(StreamingProperties.class);
            assertThat(props.getType()).isEqualTo("SSE");
            assertThat(props.getInterval()).isEqualTo(5000);
        });
    }
}
```

#### 3. Integration Tests
Full Spring Boot application tests with REST API validation.

**Base Class:** All integration tests extend `ServerApplicationTests`

**Example:**
```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class OrganizationTests extends ServerApplicationTests {

    @Test
    void shouldCreateOrganization() {
        String jsonBody = """
            {
                "data": {
                    "type": "organization",
                    "attributes": {
                        "name": "Test Org",
                        "description": "Test Description"
                    }
                }
            }
            """;

        given()
            .contentType("application/vnd.api+json")
            .header("Authorization", "Bearer " + generatePAT("TERRAKUBE_ADMIN"))
            .body(jsonBody)
        .when()
            .post("/api/v1/organization")
        .then()
            .statusCode(201)
            .body("data.attributes.name", equalTo("Test Org"));
    }
}
```

### Mocking Patterns

**Mockito Static Imports:**
```java
import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.*;
```

**Common Mocking Techniques:**
```java
// Return value
doReturn(someValue).when(mock).method();

// Throw exception
doThrow(new RuntimeException()).when(mock).method();

// Void method
doNothing().when(mock).voidMethod();

// Custom behavior
doAnswer(invocation -> {
    Entity entity = invocation.getArgument(0);
    entity.setId(UUID.randomUUID());
    return entity;
}).when(repository).save(any());

// Verify interactions
verify(mock, times(1)).method();
verify(mock, never()).method();
```

### Test Data Management

**Builder Pattern:**
```java
private Job createJob(JobStatus status) {
    Job job = new Job();
    job.setId(UUID.randomUUID());
    job.setStatus(status);
    job.setCreatedDate(Timestamp.from(Instant.now()));
    return job;
}
```

**Liquibase Demo Data:**
Integration tests use pre-populated test data from `db/changelog/changelog-demo.xml` with known UUIDs.

---

## Integration Testing

### Test Database Configuration

**Database:** H2 in-memory database
**Config File:** `api/src/test/resources/application-test.properties`

**Key Settings:**
```properties
# Database type
io.terrakube.api.plugin.datasource.type=H2

# Schema management
spring.liquibase.change-log=classpath:/db/changelog/changelog-demo.xml

# Naming strategy
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

### External Service Mocking

**WireMock Setup:**
```java
@BeforeAll
public static void setup() {
    RestAssured.port = port;
    mockExecutor = new WireMockServer(options().dynamicPort());
    mockExecutor.start();
}

@AfterAll
public static void cleanup() {
    mockExecutor.stop();
}
```

**Redis Mocking:**
```java
@MockBean
private RedisTemplate redisTemplate;
```

### Authentication in Tests

**JWT Token Generation:**
```java
// Admin token
String token = generatePAT("TERRAKUBE_ADMIN");

// Developer token
String token = generatePAT("TERRAKUBE_DEVELOPERS");

// System token
String token = generateSystemToken();
```

### Test Execution Results
- **Total Tests:** 91 tests
- **Modules:** api-server (85), registry-server (3), executor-service (3)
- **Execution Time:** ~49 seconds
- **Status:** All passing

---

## API Testing

### Thunder Client Collections

**Location:** `/thunder-tests/`

**Tool:** Thunder Client (VS Code REST API testing extension)

**Collections:**
- 28 organized test folders
- 199 API test requests
- Complete workflow coverage (Authentication â†’ Jobs â†’ Modules â†’ etc.)

**Usage:**
1. Install Thunder Client extension in VS Code
2. Open Thunder Client panel
3. Import collections from `/thunder-tests/`
4. Execute requests manually during development

**Test Categories:**
- Authentication (Dex, tokens)
- Organizations & Teams
- Workspaces & Jobs
- VCS integrations
- Modules & Providers
- Variables & State
- Terraform Protocol operations

**Note:** These are manual E2E tests, not automated in CI/CD.

---

## CI/CD Testing

### Backend CI (pull_request.yml)

**Trigger:** Push to main, pull requests

**Testing Steps:**
```yaml
- name: Build with Maven
  run: mvn -B verify --file pom.xml
```

**What's Tested:**
- Unit tests (91 tests)
- Integration tests
- Code compilation
- SonarCloud analysis (for repository PRs)

**Java Version:** JDK 25 (Liberica distribution)

### Frontend CI (pull_request_ui.yml)

**Trigger:** Push to main, PRs with `ui/**` changes

**Current Steps:**
1. `yarn install --frozen-lockfile`
2. `yarn lint:modules:check`
3. `yarn format:modules:check`
4. `npm run build --if-present`

**Gap Identified:** Frontend tests (`npm test`) are NOT executed in CI/CD

**Recommendation:** Add test execution step:
```yaml
- name: Run tests
  run: npm test -- --watchAll=false
  working-directory: ./ui
```

### Release Workflow (release.yml)

**Note:** Tests are skipped during release builds for speed (`-Dmaven.test.skip=true`)

---

## Quality Gates

### Pre-Submission Checklist

Before submitting a pull request, ensure all quality gates pass:

#### Frontend Quality Gates
```bash
cd ui

# 1. Run tests
npm test -- --watchAll=false
# âœ… All tests should pass

# 2. Check test coverage (optional but recommended)
npm test -- --coverage --watchAll=false
# âœ… Coverage should not decrease significantly

# 3. Run linting
npm run lint:check
# âœ… No new linting errors

# 4. Fix auto-fixable linting issues
npm run lint
# âœ… Auto-fixes applied

# 5. Check code formatting
npm run format:check
# âœ… All files properly formatted

# 6. Fix formatting issues
npm run format
# âœ… Formatting applied

# 7. Build the application
npm run build
# âœ… Build completes without errors
```

#### Backend Quality Gates
```bash
# From project root

# 1. Run all tests
mvn test
# âœ… All 91+ tests should pass

# 2. Run full verification (includes tests + coverage)
mvn verify
# âœ… Build and tests complete successfully

# 3. Check for compilation warnings (optional)
mvn clean compile
# âœ… No new compiler warnings
```

#### Git Pre-Commit Checks
```bash
# Check git status
git status

# Ensure you're on a feature branch, not main
git branch

# Review changes before committing
git diff

# Commit with descriptive message
git commit -m "feat: add user authentication feature"
```

### Automated Quality Gates in CI

**Backend (Enforced):**
- âœ… Unit tests execution
- âœ… Integration tests execution
- âœ… Build validation
- âœ… SonarCloud analysis

**Frontend (Enforced):**
- âœ… Linting (ESLint)
- âœ… Formatting (Prettier)
- âœ… Build validation
- âŒ Test execution (not currently enforced - gap)

---

## Writing New Tests

### Frontend Test Template

**Utility Function Test:**
```typescript
// src/utils/myUtil.spec.ts
import { myUtil } from './myUtil';

describe('myUtil', () => {
  describe('basic functionality', () => {
    test('should handle typical input correctly', () => {
      const result = myUtil('input');
      expect(result).toBe('expected output');
    });

    test('should handle edge case: empty string', () => {
      const result = myUtil('');
      expect(result).toBe('');
    });

    test('should handle edge case: null input', () => {
      const result = myUtil(null);
      expect(result).toBeNull();
    });
  });

  describe('error handling', () => {
    test('should throw error for invalid input', () => {
      expect(() => myUtil('invalid')).toThrow('Invalid input');
    });
  });
});
```

**React Component Test:**
```typescript
// src/components/MyComponent.spec.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { MyComponent } from './MyComponent';

describe('MyComponent', () => {
  test('renders with required props', () => {
    render(<MyComponent title="Test" />);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  test('handles user interaction', async () => {
    const handleClick = jest.fn();
    render(<MyComponent onClick={handleClick} />);

    const button = screen.getByRole('button', { name: /submit/i });
    await userEvent.click(button);

    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  test('updates state on input change', async () => {
    render(<MyComponent />);

    const input = screen.getByRole('textbox');
    await userEvent.type(input, 'new value');

    expect(input).toHaveValue('new value');
  });

  test('displays loading state', () => {
    render(<MyComponent isLoading={true} />);
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });
});
```

### Backend Test Template

**Unit Test with Mocks:**
```java
package org.terrakube.api.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class MyServiceTest {

    @Mock
    private MyRepository repository;

    @Mock
    private ExternalService externalService;

    private MyService myService;

    @BeforeEach
    void setup() {
        myService = new MyService(repository, externalService);
    }

    @Test
    void shouldProcessDataSuccessfully() {
        // Arrange
        MyEntity entity = createTestEntity();
        doReturn(entity).when(repository).save(any(MyEntity.class));
        doReturn("success").when(externalService).process(any());

        // Act
        String result = myService.processData(entity);

        // Assert
        assertThat(result).isEqualTo("success");
        verify(repository, times(1)).save(entity);
        verify(externalService, times(1)).process(any());
    }

    @Test
    void shouldHandleRepositoryFailure() {
        // Arrange
        MyEntity entity = createTestEntity();
        doThrow(new RuntimeException("Database error"))
            .when(repository).save(any());

        // Act & Assert
        assertThatThrownBy(() -> myService.processData(entity))
            .isInstanceOf(RuntimeException.class)
            .hasMessageContaining("Database error");
    }

    private MyEntity createTestEntity() {
        MyEntity entity = new MyEntity();
        entity.setId(UUID.randomUUID());
        entity.setName("Test");
        return entity;
    }
}
```

**Integration Test:**
```java
package org.terrakube.api;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.test.context.ActiveProfiles;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class MyApiTests extends ServerApplicationTests {

    @Test
    void shouldReturnListOfEntities() {
        given()
            .header("Authorization", "Bearer " + generatePAT("TERRAKUBE_ADMIN"))
        .when()
            .get("/api/v1/myentities")
        .then()
            .statusCode(200)
            .body("data", notNullValue())
            .body("data.size()", greaterThan(0));
    }

    @Test
    void shouldCreateNewEntity() {
        String jsonBody = """
            {
                "data": {
                    "type": "myentity",
                    "attributes": {
                        "name": "Test Entity",
                        "description": "Test Description"
                    }
                }
            }
            """;

        given()
            .contentType("application/vnd.api+json")
            .header("Authorization", "Bearer " + generatePAT("TERRAKUBE_ADMIN"))
            .body(jsonBody)
        .when()
            .post("/api/v1/myentity")
        .then()
            .statusCode(201)
            .body("data.attributes.name", equalTo("Test Entity"))
            .body("data.id", notNullValue());
    }

    @Test
    void shouldReturnUnauthorizedWithoutToken() {
        given()
        .when()
            .get("/api/v1/myentities")
        .then()
            .statusCode(401);
    }
}
```

---

## Best Practices

### General Testing Principles

1. **Write Tests First (TDD):** Consider writing tests before implementation
2. **Test One Thing:** Each test should verify a single behavior
3. **Descriptive Names:** Test names should clearly describe what they test
4. **Arrange-Act-Assert:** Structure tests with clear phases
5. **Independent Tests:** Tests should not depend on each other
6. **Fast Tests:** Keep unit tests fast (<1s each)
7. **Deterministic:** Tests should always produce the same result

### Frontend Best Practices

1. **Test User Behavior:** Focus on what users see and do, not implementation details
2. **Avoid Testing Implementation:** Don't test internal component state directly
3. **Use Semantic Queries:** Prefer `getByRole`, `getByLabelText` over `getByTestId`
4. **Mock External Dependencies:** Mock API calls, external services
5. **Test Accessibility:** Include tests for keyboard navigation, screen readers
6. **Snapshot Sparingly:** Use snapshot tests carefully, they can be fragile

**Good:**
```typescript
// Tests user-visible behavior
expect(screen.getByRole('button', { name: /submit/i })).toBeEnabled();
```

**Bad:**
```typescript
// Tests implementation details
expect(component.state.isSubmitting).toBe(false);
```

### Backend Best Practices

1. **Mock External Dependencies:** Use Mockito to mock repositories, services
2. **Use Test Data Builders:** Create helper methods for test data
3. **Verify Interactions:** Use `verify()` to ensure correct method calls
4. **Test Edge Cases:** Include null checks, empty collections, errors
5. **Use AssertJ:** Prefer fluent assertions for readability
6. **Integration Tests for APIs:** Test full request-response cycle
7. **H2 for Speed:** Use in-memory database for fast integration tests

### Code Coverage Guidelines

- **Target:** Aim for >80% code coverage
- **Quality over Quantity:** 100% coverage doesn't guarantee quality
- **Cover Critical Paths:** Focus on business logic, error handling
- **Ignore Generated Code:** Don't test auto-generated code
- **Test Boundaries:** Focus on public APIs, not private methods

### Test Organization

**Frontend:**
- Co-locate tests with source files
- Use `.spec.ts` or `.spec.tsx` extension
- Group related tests with `describe()` blocks

**Backend:**
- Mirror source package structure in `src/test/java`
- Separate unit tests from integration tests
- Use clear class naming: `ClassNameTest`, `ClassNameTests`

---

## Troubleshooting

### Frontend Test Issues

**Problem:** Tests fail with module resolution errors

**Solution:** Check `jest.config.js` path mappings match `tsconfig.json`

```javascript
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/src/$1',
}
```

**Problem:** CSS/SCSS import errors

**Solution:** Ensure `identity-obj-proxy` is configured for style mocks

```javascript
moduleNameMapper: {
  '\\.(css|scss)$': 'identity-obj-proxy',
}
```

**Problem:** SVG import errors

**Solution:** Use `jest-transformer-svg` for SVG mocking

### Backend Test Issues

**Problem:** H2 database compatibility issues

**Solution:** Check `application-test.properties` configuration

**Problem:** Liquibase migration failures

**Solution:** Verify `changelog-demo.xml` is accessible and valid

**Problem:** WireMock port conflicts

**Solution:** Use dynamic port allocation: `options().dynamicPort()`

**Problem:** Mock not working as expected

**Solution:** Use `FailUnknownMethod` helper to catch unmocked calls

---

## Additional Resources

### Documentation
- [Jest Documentation](https://jestjs.io/)
- [React Testing Library](https://testing-library.com/react)
- [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)
- [Mockito Documentation](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)
- [REST Assured](https://rest-assured.io/)
- [AssertJ](https://assertj.github.io/doc/)

### Internal Resources
- Backend architecture: `/Auto Run Docs/backend-architecture.md`
- CI/CD workflows: `.github/workflows/`
- Test data: `api/src/test/resources/db/changelog/changelog-demo.xml`
- Integration test base: `api/src/test/java/org/terrakube/api/ServerApplicationTests.java`

---

## Summary

Terrakube has comprehensive testing infrastructure for both frontend and backend:

**Frontend:**
- Jest + React Testing Library
- 98%+ test coverage on tested modules
- Linting and formatting enforced

**Backend:**
- JUnit 5 + Mockito + Spring Test
- 91 tests across 3 modules
- REST Assured for API integration tests
- H2 in-memory database for fast tests

**Key Gaps:**
- Frontend tests not executed in CI/CD (should be added)
- No browser-based E2E tests (Cypress/Playwright)
- Thunder Client collections are manual, not automated

**Before Contributing:**
Run all quality gates (tests, linting, formatting) to ensure clean pull requests.

Happy testing! ðŸ§ª
