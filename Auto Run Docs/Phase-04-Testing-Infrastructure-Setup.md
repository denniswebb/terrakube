# Phase 04: Testing Setup & Quality Assurance

This phase establishes testing infrastructure for both frontend and backend, ensures you can run existing tests, and prepares you to write tests for your contributions. Good testing practices are essential for maintaining quality while fixing rough edges.

## Tasks

- [x] Navigate to ui directory and run `npm test` to execute frontend tests and verify test infrastructure works
  - **Completed**: Frontend test infrastructure verified working with Jest
  - **Results**: 3 test suites passed (17 tests total) in 1.223s
  - **Test files**: formatSshUrl.spec.ts, getVcsNameFromUrl.spec.ts, getVcsTypeFromUrl.spec.ts
  - **Command used**: `cd ui && npm test -- --watchAll=false`
- [x] Review the frontend testing setup in package.json to understand the testing framework (Jest, React Testing Library, etc.)
  - **Testing Framework**: Jest (v30.2.0) with ts-jest for TypeScript support
  - **Testing Library**: @testing-library/react (v16.3.1) and @testing-library/jest-dom (v6.9.1)
  - **Test Environment**: jsdom for DOM simulation
  - **Test Command**: `npm test` (runs Jest)
  - **Configuration Files**:
    - `jest.config.js`: Main Jest configuration with jsdom environment, ts-jest transform, CSS/SVG module mapping, path aliases (@/)
    - `jest.setup.ts`: Imports @testing-library/jest-dom for custom matchers
    - `tsconfig.test.json`: TypeScript configuration for tests with ES2020 target and strict mode
  - **Key Features**:
    - TypeScript support via ts-jest transformer
    - CSS/SCSS module mocking with identity-obj-proxy
    - SVG mocking with jest-transformer-svg
    - Path alias support (@/* → src/*)
    - Custom Jest matchers from jest-dom (e.g., toHaveTextContent, toBeInTheDocument)
- [x] Examine 2-3 existing frontend component tests to understand testing patterns and conventions
  - **Files Analyzed**:
    - `ui/src/modules/workspaces/utils/formatSshUrl.spec.ts` (7 tests)
    - `ui/src/modules/workspaces/utils/getVcsNameFromUrl.spec.ts` (4 tests)
    - `ui/src/modules/workspaces/utils/getVcsTypeFromUrl.spec.ts` (6 tests)
  - **Testing Patterns Identified**:
    - **File Naming**: `.spec.ts` extension for test files, co-located with source files
    - **Structure**: `describe()` blocks group related tests, `test()` for individual test cases
    - **Assertions**: Standard Jest `expect()` with matchers like `toBe()`
    - **Test Organization**: Organized by feature/scenario, descriptive test names
    - **Pure Function Testing**: Tests focus on utility functions with clear inputs/outputs
    - **Import Style**: Direct imports from adjacent files using relative paths
    - **Type Safety**: Tests use TypeScript with proper types (e.g., `VcsType` enum)
    - **Async Handling**: Some tests marked `async` even when not awaiting (likely for consistency)
  - **Testing Conventions**:
    - Tests validate VCS URL parsing/formatting for multiple providers (GitHub, GitLab, Bitbucket, Azure DevOps)
    - Each test case covers a specific VCS provider or URL format variant
    - Descriptive test names follow pattern: "[Provider/Feature] [action] [expected result]"
    - Tests are comprehensive, covering edge cases like SSH vs HTTPS URLs, different domain patterns
    - No mocking needed for these utility functions (pure functions with deterministic outputs)
- [x] Verify test coverage can be generated by running `npm test -- --coverage` and reviewing the output
  - **Completed**: Test coverage report generation verified working successfully
  - **Command used**: `cd ui && npm test -- --coverage --watchAll=false`
  - **Overall Coverage Metrics**:
    - **Statements**: 98.96% covered
    - **Branches**: 97.61% covered
    - **Functions**: 100% covered
    - **Lines**: 98.91% covered
  - **Coverage by Directory**:
    - `domain/types.ts`: 100% coverage across all metrics
    - `modules/workspaces/utils/`: 97.87% statements, 96.42% branches, 100% functions, 97.61% lines
      - `formatSshUrl.ts`: 100% coverage (all metrics)
      - `getVcsNameFromUrl.ts`: 100% coverage (all metrics)
      - `getVcsTypeFromUrl.ts`: 95% statements, 91.66% branches, 100% functions, 93.33% lines (line 19 uncovered)
  - **Test Execution**: 3 test suites passed, 17 tests passed, 0.941s runtime
  - **Coverage Output**: Displays comprehensive table format with file-by-file breakdown
  - **Uncovered Code**: Only 1 uncovered line identified (getVcsTypeFromUrl.ts:19)
  - **Key Observations**:
    - Excellent overall coverage (>97% across all metrics)
    - Coverage reporting infrastructure is properly configured
    - Minor gap in getVcsTypeFromUrl.ts edge case handling
- [x] Navigate to api directory and run backend tests using Maven with `./mvnw test` or `mvn test`
  - **Completed**: Backend tests successfully executed with Maven
  - **Setup**: Installed Java 25 and Maven 3.9.12 via mise tool manager
  - **Issue Fixed**: Added missing `java.util.Set` import to `ExecutorService.java:12`
  - **Command used**: `mise exec -- mvn test` (from project root)
  - **Results**: All 91 tests passed successfully across all modules (api, registry, executor)
  - **Execution time**: ~49 seconds total
  - **Test modules executed**:
    - api-server: 85 tests passed
    - registry-server: 3 tests passed
    - executor-service: 3 tests passed
  - **Build success**: No test failures, compilation successful after import fix
- [x] Review the backend testing setup and identify testing frameworks used (JUnit, Mockito, etc.)
  - **Completed**: Backend testing framework identified from Maven POM files
  - **Primary Testing Framework**: JUnit (via spring-boot-starter-test)
  - **Testing Dependencies**:
    - **JUnit 5 (Jupiter)**: Core testing framework included in spring-boot-starter-test
    - **Mockito**: Mocking framework included in spring-boot-starter-test
    - **Spring Test**: Spring testing utilities (spring-boot-starter-test)
    - **Spring Security Test**: Security testing support (spring-security-test) in API module
    - **AssertJ**: Fluent assertions included in spring-boot-starter-test
    - **Hamcrest**: Matcher library included in spring-boot-starter-test
    - **JSONassert**: JSON comparison included in spring-boot-starter-test
    - **JsonPath**: JSON path queries included in spring-boot-starter-test
  - **API-Specific Testing Tools**:
    - **REST Assured (v5.5.6)**: API testing library for REST endpoints
    - **WireMock Spring Boot (v4.0.8)**: HTTP mocking for integration tests
    - **Elide Test Helpers (v7.1.15)**: Testing utilities for Elide framework
    - **Handlebars (v4.3.1)**: Template testing support
  - **Test Database**: H2 in-memory database for testing (scope: runtime)
  - **Code Coverage**: JaCoCo Maven Plugin (v0.8.14) configured at platform level
  - **Test Scope**: All modules (api-server with 85 tests, registry-server with 3 tests, executor-service with 3 tests)
  - **Key Observations**:
    - Spring Boot Test starter provides comprehensive testing stack
    - API module has most extensive testing setup with REST API testing tools
    - Registry and Executor modules use simplified testing setup
    - JaCoCo coverage reporting integrated with SonarCloud
    - All modules inherit from Spring Boot parent (v3.5.7) for consistent testing framework versions
- [x] Examine 2-3 existing backend unit tests to understand mocking patterns and test structure
  - **Completed**: Analyzed 3 backend test files to understand testing patterns
  - **Files Analyzed**:
    - `ScheduleJobTest.java` (26 test methods, 667 lines) - Complex service integration testing
    - `PersistentExecutorServiceTest.java` (6 test methods, 175 lines) - HTTP client mocking patterns
    - `StreamingPropertiesTest.java` (1 test method, 54 lines) - Configuration properties testing
  - **Testing Framework Stack**:
    - **JUnit 5**: `@Test`, `@BeforeEach`, `@ExtendWith(MockitoExtension.class)`
    - **Mockito**: Extensive mocking with `mock()`, `doReturn()`, `verify()`, `times()`
    - **AssertJ**: Fluent assertions with `assertThat()` API
    - **Spring Test**: `ApplicationContextRunner` for configuration testing
  - **Mocking Patterns Identified**:
    - **Custom Mock Answer**: `FailUnkownMethod<T>` helper class ensures strict mocking (any unmocked method throws exception)
    - **Setup Method Pattern**: `@BeforeEach setup()` initializes all mocks consistently
    - **Subject Factory**: Private `subject()` method constructs service under test with mocked dependencies
    - **Test Data Builders**: Private helper methods like `job(JobStatus)`, `jobOnDefaultExecutor()` create test fixtures
    - **Mockito Static Imports**: Extensive use of static imports for cleaner test code (`doReturn`, `verify`, `any`, `times`)
    - **Argument Matchers**: `any()`, `anyString()`, `anyInt()`, `anyList()` for flexible matching
    - **Behavior Verification**: `verify(mock, times(n)).method()` to assert interaction counts
    - **Exception Testing**: `assertThrows(ExceptionClass.class, () -> method())` for exception scenarios
  - **Test Structure Conventions**:
    - **Arrange-Act-Assert**: Clear three-phase structure in each test method
    - **Given-When-Then**: Implicit pattern through mock setup, action, and verification
    - **Descriptive Names**: Test method names describe scenarios (e.g., `expiredJobsAreDescheduled`, `propagatesMalformedUri`)
    - **Single Responsibility**: Each test validates one specific behavior or edge case
    - **Comprehensive Coverage**: Tests cover success paths, failure paths, edge cases, and error handling
  - **Advanced Mocking Techniques**:
    - **doAnswer()**: Custom behavior injection for complex mock responses (e.g., setting ID on saved entity)
    - **doThrow()**: Exception simulation for failure scenarios
    - **doNothing()**: Void method mocking for services with no return value
    - **Mock Chains**: WebClient builder pattern fully mocked with chained method calls
    - **Generic Suppression**: `@SuppressWarnings("unchecked")` for generic type safety in mocks
  - **Configuration Testing Pattern**:
    - **ApplicationContextRunner**: Spring Boot test context for property binding validation
    - **@EnableConfigurationProperties**: Enables configuration class loading in test context
    - **Property Values**: `.withPropertyValues()` injects test configuration
    - **Fluent Assertions**: AssertJ `assertThat()` with property accessors for readable assertions
  - **Test Data Management**:
    - Domain objects (Job, Workspace, Organization) constructed programmatically
    - UUIDs generated for test data uniqueness
    - Collections (Lists, Maps) used for complex test scenarios
    - Optional wrapping for repository return values
  - **Key Observations**:
    - Heavy use of Mockito for dependency isolation
    - FailUnkownMethod ensures strict test discipline (no accidental behavior)
    - Tests focus on business logic, not Spring integration (unit tests, not integration tests)
    - Comprehensive mocking allows testing without database or external services
    - Clear separation between unit tests (mocked dependencies) and configuration tests (Spring context)
- [x] Look for integration tests that test API endpoints with a test database
  - **Completed**: Comprehensive integration test suite identified in api/src/test/java/io/terrakube/api/
  - **Integration Test Files Found**: 16 test classes using REST Assured for API endpoint testing
  - **Key Test Files**:
    - `ServerApplicationTests.java`: Base class for all integration tests with Spring Boot test setup
    - `OrganizationTests.java`: Organization API endpoint tests (4 tests)
    - `WorkspaceTests.java`: Workspace API endpoint tests (15 tests)
    - `JobTests.java`, `TeamTests.java`, `VcsTests.java`, `ModuleTests.java`, `ProviderTests.java`, etc.
  - **Integration Testing Framework Stack**:
    - **@SpringBootTest**: Full Spring application context with `WebEnvironment.RANDOM_PORT`
    - **REST Assured**: Fluent API testing library for HTTP endpoint validation
    - **WireMock**: HTTP mocking for external service integration
    - **H2 Database**: In-memory test database configured via `application-test.properties`
    - **Liquibase**: Database schema and demo data setup using `changelog-demo.xml`
    - **@ActiveProfiles("test")**: Activates test-specific configuration profile
  - **Integration Test Patterns**:
    - **Base Class Pattern**: All integration tests extend `ServerApplicationTests` for shared setup
    - **@BeforeAll Setup**: Initializes REST Assured port and WireMock server (per-class lifecycle)
    - **@AfterAll Cleanup**: Stops WireMock server after all tests complete
    - **Mock Redis**: `@MockBean RedisTemplate` to avoid external Redis dependency
    - **JWT Token Generation**: Helper methods `generatePAT()` and `generateSystemToken()` for authentication
    - **Test Data**: Liquibase demo data provides pre-populated test entities with known UUIDs
  - **API Testing Pattern**:
    - **Given-When-Then**: REST Assured fluent API (`given()...when()...then()`)
    - **Authorization Headers**: JWT tokens generated for different user roles (TERRAKUBE_ADMIN, TERRAKUBE_DEVELOPERS, FAKE_GROUP)
    - **JSON:API Format**: Request/response validation using `application/vnd.api+json` content type
    - **HTTP Status Assertions**: Validate response codes (200 OK, 201 CREATED, 403 FORBIDDEN, 401 UNAUTHORIZED)
    - **Response Body Assertions**: Hamcrest matchers for JSON path validation (e.g., `equalTo()`)
    - **CRUD Operations**: Full lifecycle tests (Create, Read, Update, Delete operations)
    - **Permission Testing**: Verify authorization rules for different user roles
  - **Test Database Configuration** (application-test.properties):
    - **Database Type**: H2 in-memory database (`io.terrakube.api.plugin.datasource.type=H2`)
    - **Schema Management**: Liquibase enabled with `spring.liquibase.change-log=classpath:/db/changelog/changelog-demo.xml`
    - **Demo Data**: Pre-populated organizations, workspaces, teams, jobs via Liquibase changesets
    - **Naming Strategy**: Standard physical naming (not snake_case conversion)
    - **Quartz**: JDBC job store for scheduled task testing
  - **External Service Mocking**:
    - **WireMock Server**: Dynamic port allocation for mocking external HTTP services
    - **Redis Mock**: MockBean for Redis operations (no actual Redis required)
    - **Executor Service**: Mocked executor URL for job execution tests
  - **Test Data Management**:
    - **Known UUIDs**: Fixed entity IDs from Liquibase demo data (e.g., organization `d9b58bd3-f3fc-4056-a026-1163297e80a8`)
    - **File System State**: Tests create/cleanup Terraform state files in `.terraform-spring-boot/local/backend/`
    - **Team Permissions**: Tests modify team permissions dynamically (e.g., `setManageState(true)`)
    - **Test Isolation**: Each test operates on known entities, cleanup performed in some tests (e.g., workspace deletion)
  - **Key Observations**:
    - Integration tests validate full request-response cycle with real database
    - Tests cover API authorization, JSON:API compliance, business logic
    - WireMock enables testing external integrations without live services
    - Demo data provides realistic test scenarios with relationships (org → workspace → job)
    - Tests run fast (~49s for 91 tests) due to H2 in-memory database
    - No manual database setup required - Liquibase handles schema + data automatically
- [ ] Check for any end-to-end tests in a separate e2e directory or test suite
- [ ] Verify linting works by running `npm run lint` in the ui directory (if configured)
- [ ] Check for code formatting configuration (Prettier, ESLint) and run formatting checks
- [ ] Identify continuous integration configuration (.github/workflows, .gitlab-ci.yml) to understand CI/CD testing
- [ ] Document the testing strategy in testing-guide.md in Auto Run Docs including how to run tests and write new ones
- [ ] Create a checklist of quality gates to run before submitting contributions (tests, linting, formatting)
- [ ] Identify any gaps in test coverage that should be addressed when fixing bugs or adding features