# Phase 04: Testing Setup & Quality Assurance

This phase establishes testing infrastructure for both frontend and backend, ensures you can run existing tests, and prepares you to write tests for your contributions. Good testing practices are essential for maintaining quality while fixing rough edges.

## Tasks

- [x] Navigate to ui directory and run `npm test` to execute frontend tests and verify test infrastructure works
  - **Completed**: Frontend test infrastructure verified working with Jest
  - **Results**: 3 test suites passed (17 tests total) in 1.223s
  - **Test files**: formatSshUrl.spec.ts, getVcsNameFromUrl.spec.ts, getVcsTypeFromUrl.spec.ts
  - **Command used**: `cd ui && npm test -- --watchAll=false`
- [x] Review the frontend testing setup in package.json to understand the testing framework (Jest, React Testing Library, etc.)
  - **Testing Framework**: Jest (v30.2.0) with ts-jest for TypeScript support
  - **Testing Library**: @testing-library/react (v16.3.1) and @testing-library/jest-dom (v6.9.1)
  - **Test Environment**: jsdom for DOM simulation
  - **Test Command**: `npm test` (runs Jest)
  - **Configuration Files**:
    - `jest.config.js`: Main Jest configuration with jsdom environment, ts-jest transform, CSS/SVG module mapping, path aliases (@/)
    - `jest.setup.ts`: Imports @testing-library/jest-dom for custom matchers
    - `tsconfig.test.json`: TypeScript configuration for tests with ES2020 target and strict mode
  - **Key Features**:
    - TypeScript support via ts-jest transformer
    - CSS/SCSS module mocking with identity-obj-proxy
    - SVG mocking with jest-transformer-svg
    - Path alias support (@/* → src/*)
    - Custom Jest matchers from jest-dom (e.g., toHaveTextContent, toBeInTheDocument)
- [x] Examine 2-3 existing frontend component tests to understand testing patterns and conventions
  - **Files Analyzed**:
    - `ui/src/modules/workspaces/utils/formatSshUrl.spec.ts` (7 tests)
    - `ui/src/modules/workspaces/utils/getVcsNameFromUrl.spec.ts` (4 tests)
    - `ui/src/modules/workspaces/utils/getVcsTypeFromUrl.spec.ts` (6 tests)
  - **Testing Patterns Identified**:
    - **File Naming**: `.spec.ts` extension for test files, co-located with source files
    - **Structure**: `describe()` blocks group related tests, `test()` for individual test cases
    - **Assertions**: Standard Jest `expect()` with matchers like `toBe()`
    - **Test Organization**: Organized by feature/scenario, descriptive test names
    - **Pure Function Testing**: Tests focus on utility functions with clear inputs/outputs
    - **Import Style**: Direct imports from adjacent files using relative paths
    - **Type Safety**: Tests use TypeScript with proper types (e.g., `VcsType` enum)
    - **Async Handling**: Some tests marked `async` even when not awaiting (likely for consistency)
  - **Testing Conventions**:
    - Tests validate VCS URL parsing/formatting for multiple providers (GitHub, GitLab, Bitbucket, Azure DevOps)
    - Each test case covers a specific VCS provider or URL format variant
    - Descriptive test names follow pattern: "[Provider/Feature] [action] [expected result]"
    - Tests are comprehensive, covering edge cases like SSH vs HTTPS URLs, different domain patterns
    - No mocking needed for these utility functions (pure functions with deterministic outputs)
- [x] Verify test coverage can be generated by running `npm test -- --coverage` and reviewing the output
  - **Completed**: Test coverage report generation verified working successfully
  - **Command used**: `cd ui && npm test -- --coverage --watchAll=false`
  - **Overall Coverage Metrics**:
    - **Statements**: 98.96% covered
    - **Branches**: 97.61% covered
    - **Functions**: 100% covered
    - **Lines**: 98.91% covered
  - **Coverage by Directory**:
    - `domain/types.ts`: 100% coverage across all metrics
    - `modules/workspaces/utils/`: 97.87% statements, 96.42% branches, 100% functions, 97.61% lines
      - `formatSshUrl.ts`: 100% coverage (all metrics)
      - `getVcsNameFromUrl.ts`: 100% coverage (all metrics)
      - `getVcsTypeFromUrl.ts`: 95% statements, 91.66% branches, 100% functions, 93.33% lines (line 19 uncovered)
  - **Test Execution**: 3 test suites passed, 17 tests passed, 0.941s runtime
  - **Coverage Output**: Displays comprehensive table format with file-by-file breakdown
  - **Uncovered Code**: Only 1 uncovered line identified (getVcsTypeFromUrl.ts:19)
  - **Key Observations**:
    - Excellent overall coverage (>97% across all metrics)
    - Coverage reporting infrastructure is properly configured
    - Minor gap in getVcsTypeFromUrl.ts edge case handling
- [x] Navigate to api directory and run backend tests using Maven with `./mvnw test` or `mvn test`
  - **Completed**: Backend tests successfully executed with Maven
  - **Setup**: Installed Java 25 and Maven 3.9.12 via mise tool manager
  - **Issue Fixed**: Added missing `java.util.Set` import to `ExecutorService.java:12`
  - **Command used**: `mise exec -- mvn test` (from project root)
  - **Results**: All 91 tests passed successfully across all modules (api, registry, executor)
  - **Execution time**: ~49 seconds total
  - **Test modules executed**:
    - api-server: 85 tests passed
    - registry-server: 3 tests passed
    - executor-service: 3 tests passed
  - **Build success**: No test failures, compilation successful after import fix
- [x] Review the backend testing setup and identify testing frameworks used (JUnit, Mockito, etc.)
  - **Completed**: Backend testing framework identified from Maven POM files
  - **Primary Testing Framework**: JUnit (via spring-boot-starter-test)
  - **Testing Dependencies**:
    - **JUnit 5 (Jupiter)**: Core testing framework included in spring-boot-starter-test
    - **Mockito**: Mocking framework included in spring-boot-starter-test
    - **Spring Test**: Spring testing utilities (spring-boot-starter-test)
    - **Spring Security Test**: Security testing support (spring-security-test) in API module
    - **AssertJ**: Fluent assertions included in spring-boot-starter-test
    - **Hamcrest**: Matcher library included in spring-boot-starter-test
    - **JSONassert**: JSON comparison included in spring-boot-starter-test
    - **JsonPath**: JSON path queries included in spring-boot-starter-test
  - **API-Specific Testing Tools**:
    - **REST Assured (v5.5.6)**: API testing library for REST endpoints
    - **WireMock Spring Boot (v4.0.8)**: HTTP mocking for integration tests
    - **Elide Test Helpers (v7.1.15)**: Testing utilities for Elide framework
    - **Handlebars (v4.3.1)**: Template testing support
  - **Test Database**: H2 in-memory database for testing (scope: runtime)
  - **Code Coverage**: JaCoCo Maven Plugin (v0.8.14) configured at platform level
  - **Test Scope**: All modules (api-server with 85 tests, registry-server with 3 tests, executor-service with 3 tests)
  - **Key Observations**:
    - Spring Boot Test starter provides comprehensive testing stack
    - API module has most extensive testing setup with REST API testing tools
    - Registry and Executor modules use simplified testing setup
    - JaCoCo coverage reporting integrated with SonarCloud
    - All modules inherit from Spring Boot parent (v3.5.7) for consistent testing framework versions
- [x] Examine 2-3 existing backend unit tests to understand mocking patterns and test structure
  - **Completed**: Analyzed 3 backend test files to understand testing patterns
  - **Files Analyzed**:
    - `ScheduleJobTest.java` (26 test methods, 667 lines) - Complex service integration testing
    - `PersistentExecutorServiceTest.java` (6 test methods, 175 lines) - HTTP client mocking patterns
    - `StreamingPropertiesTest.java` (1 test method, 54 lines) - Configuration properties testing
  - **Testing Framework Stack**:
    - **JUnit 5**: `@Test`, `@BeforeEach`, `@ExtendWith(MockitoExtension.class)`
    - **Mockito**: Extensive mocking with `mock()`, `doReturn()`, `verify()`, `times()`
    - **AssertJ**: Fluent assertions with `assertThat()` API
    - **Spring Test**: `ApplicationContextRunner` for configuration testing
  - **Mocking Patterns Identified**:
    - **Custom Mock Answer**: `FailUnkownMethod<T>` helper class ensures strict mocking (any unmocked method throws exception)
    - **Setup Method Pattern**: `@BeforeEach setup()` initializes all mocks consistently
    - **Subject Factory**: Private `subject()` method constructs service under test with mocked dependencies
    - **Test Data Builders**: Private helper methods like `job(JobStatus)`, `jobOnDefaultExecutor()` create test fixtures
    - **Mockito Static Imports**: Extensive use of static imports for cleaner test code (`doReturn`, `verify`, `any`, `times`)
    - **Argument Matchers**: `any()`, `anyString()`, `anyInt()`, `anyList()` for flexible matching
    - **Behavior Verification**: `verify(mock, times(n)).method()` to assert interaction counts
    - **Exception Testing**: `assertThrows(ExceptionClass.class, () -> method())` for exception scenarios
  - **Test Structure Conventions**:
    - **Arrange-Act-Assert**: Clear three-phase structure in each test method
    - **Given-When-Then**: Implicit pattern through mock setup, action, and verification
    - **Descriptive Names**: Test method names describe scenarios (e.g., `expiredJobsAreDescheduled`, `propagatesMalformedUri`)
    - **Single Responsibility**: Each test validates one specific behavior or edge case
    - **Comprehensive Coverage**: Tests cover success paths, failure paths, edge cases, and error handling
  - **Advanced Mocking Techniques**:
    - **doAnswer()**: Custom behavior injection for complex mock responses (e.g., setting ID on saved entity)
    - **doThrow()**: Exception simulation for failure scenarios
    - **doNothing()**: Void method mocking for services with no return value
    - **Mock Chains**: WebClient builder pattern fully mocked with chained method calls
    - **Generic Suppression**: `@SuppressWarnings("unchecked")` for generic type safety in mocks
  - **Configuration Testing Pattern**:
    - **ApplicationContextRunner**: Spring Boot test context for property binding validation
    - **@EnableConfigurationProperties**: Enables configuration class loading in test context
    - **Property Values**: `.withPropertyValues()` injects test configuration
    - **Fluent Assertions**: AssertJ `assertThat()` with property accessors for readable assertions
  - **Test Data Management**:
    - Domain objects (Job, Workspace, Organization) constructed programmatically
    - UUIDs generated for test data uniqueness
    - Collections (Lists, Maps) used for complex test scenarios
    - Optional wrapping for repository return values
  - **Key Observations**:
    - Heavy use of Mockito for dependency isolation
    - FailUnkownMethod ensures strict test discipline (no accidental behavior)
    - Tests focus on business logic, not Spring integration (unit tests, not integration tests)
    - Comprehensive mocking allows testing without database or external services
    - Clear separation between unit tests (mocked dependencies) and configuration tests (Spring context)
- [x] Look for integration tests that test API endpoints with a test database
  - **Completed**: Comprehensive integration test suite identified in api/src/test/java/io/terrakube/api/
  - **Integration Test Files Found**: 16 test classes using REST Assured for API endpoint testing
  - **Key Test Files**:
    - `ServerApplicationTests.java`: Base class for all integration tests with Spring Boot test setup
    - `OrganizationTests.java`: Organization API endpoint tests (4 tests)
    - `WorkspaceTests.java`: Workspace API endpoint tests (15 tests)
    - `JobTests.java`, `TeamTests.java`, `VcsTests.java`, `ModuleTests.java`, `ProviderTests.java`, etc.
  - **Integration Testing Framework Stack**:
    - **@SpringBootTest**: Full Spring application context with `WebEnvironment.RANDOM_PORT`
    - **REST Assured**: Fluent API testing library for HTTP endpoint validation
    - **WireMock**: HTTP mocking for external service integration
    - **H2 Database**: In-memory test database configured via `application-test.properties`
    - **Liquibase**: Database schema and demo data setup using `changelog-demo.xml`
    - **@ActiveProfiles("test")**: Activates test-specific configuration profile
  - **Integration Test Patterns**:
    - **Base Class Pattern**: All integration tests extend `ServerApplicationTests` for shared setup
    - **@BeforeAll Setup**: Initializes REST Assured port and WireMock server (per-class lifecycle)
    - **@AfterAll Cleanup**: Stops WireMock server after all tests complete
    - **Mock Redis**: `@MockBean RedisTemplate` to avoid external Redis dependency
    - **JWT Token Generation**: Helper methods `generatePAT()` and `generateSystemToken()` for authentication
    - **Test Data**: Liquibase demo data provides pre-populated test entities with known UUIDs
  - **API Testing Pattern**:
    - **Given-When-Then**: REST Assured fluent API (`given()...when()...then()`)
    - **Authorization Headers**: JWT tokens generated for different user roles (TERRAKUBE_ADMIN, TERRAKUBE_DEVELOPERS, FAKE_GROUP)
    - **JSON:API Format**: Request/response validation using `application/vnd.api+json` content type
    - **HTTP Status Assertions**: Validate response codes (200 OK, 201 CREATED, 403 FORBIDDEN, 401 UNAUTHORIZED)
    - **Response Body Assertions**: Hamcrest matchers for JSON path validation (e.g., `equalTo()`)
    - **CRUD Operations**: Full lifecycle tests (Create, Read, Update, Delete operations)
    - **Permission Testing**: Verify authorization rules for different user roles
  - **Test Database Configuration** (application-test.properties):
    - **Database Type**: H2 in-memory database (`io.terrakube.api.plugin.datasource.type=H2`)
    - **Schema Management**: Liquibase enabled with `spring.liquibase.change-log=classpath:/db/changelog/changelog-demo.xml`
    - **Demo Data**: Pre-populated organizations, workspaces, teams, jobs via Liquibase changesets
    - **Naming Strategy**: Standard physical naming (not snake_case conversion)
    - **Quartz**: JDBC job store for scheduled task testing
  - **External Service Mocking**:
    - **WireMock Server**: Dynamic port allocation for mocking external HTTP services
    - **Redis Mock**: MockBean for Redis operations (no actual Redis required)
    - **Executor Service**: Mocked executor URL for job execution tests
  - **Test Data Management**:
    - **Known UUIDs**: Fixed entity IDs from Liquibase demo data (e.g., organization `d9b58bd3-f3fc-4056-a026-1163297e80a8`)
    - **File System State**: Tests create/cleanup Terraform state files in `.terraform-spring-boot/local/backend/`
    - **Team Permissions**: Tests modify team permissions dynamically (e.g., `setManageState(true)`)
    - **Test Isolation**: Each test operates on known entities, cleanup performed in some tests (e.g., workspace deletion)
  - **Key Observations**:
    - Integration tests validate full request-response cycle with real database
    - Tests cover API authorization, JSON:API compliance, business logic
    - WireMock enables testing external integrations without live services
    - Demo data provides realistic test scenarios with relationships (org → workspace → job)
    - Tests run fast (~49s for 91 tests) due to H2 in-memory database
    - No manual database setup required - Liquibase handles schema + data automatically
- [x] Check for any end-to-end tests in a separate e2e directory or test suite
  - **Completed**: Comprehensive search for e2e testing infrastructure across project
  - **Finding**: No dedicated e2e test framework (Cypress, Playwright, Selenium) configured
  - **Alternative E2E Testing Found**: Thunder Client API testing collection
    - **Location**: `/thunder-tests/` directory
    - **Tool**: Thunder Client (VS Code REST API client extension)
    - **Test Collections**:
      - `thunderCollection.json`: Test organization with 28 folders/categories
      - `thunderclient.json`: 199 API test requests (2940 lines)
      - `thunderActivity.json`: Test execution history
    - **Test Coverage Categories**:
      - Step 0-16: Complete API workflow testing (Authentication → Organizations → Teams → Templates → Workspaces → Jobs → VCS → Modules → SSH → PAT → Context → Global Variables → Remote State → Agents)
      - Terraform Protocol: Login, Module, Cloud operations
      - Cloud Providers: AWS, Azure, GCP workspace examples with variables
      - OpenAPI specification testing
      - Dex authentication testing
    - **Test Organization**: Organized by feature/workflow steps with nested folder structure
    - **Authentication**: Bearer token authentication with `{{device_access_token}}` variable
  - **CI/CD E2E Testing**: Not configured in GitHub Actions workflows
    - **Backend Workflow** (`pull_request.yml`): Runs unit + integration tests via `mvn verify`
    - **UI Workflow** (`pull_request_ui.yml`): Runs linting, formatting, and build - **NO test execution**
    - **Gap Identified**: UI tests (`npm test`) not executed in CI/CD pipeline
  - **Key Observations**:
    - Thunder Client provides manual API e2e testing capability (not automated in CI)
    - Integration tests in backend serve as partial e2e tests (API endpoints + database)
    - No browser-based e2e testing for UI workflows (no Cypress/Playwright)
    - Frontend unit tests exist but aren't run in CI/CD
    - Manual testing workflow via Thunder Client collections for API validation
  - **Recommendations for Contributors**:
    - Use Thunder Client collections for manual API e2e testing during development
    - Backend integration tests provide automated API endpoint validation
    - Consider adding browser e2e tests (Playwright/Cypress) for critical UI workflows
    - Add `npm test` step to UI workflow for automated frontend test execution in CI
- [x] Verify linting works by running `npm run lint` in the ui directory (if configured)
  - **Completed**: ESLint linting infrastructure verified working successfully
  - **Command used**: `cd ui && npm run lint:check`
  - **ESLint Configuration**:
    - **Config File**: `eslint.config.js` (ESLint 9+ flat config format)
    - **TypeScript Support**: typescript-eslint with recommended rules
    - **React Support**: eslint-plugin-react with flat config, auto-detects React version
    - **Accessibility**: eslint-plugin-jsx-a11y for WCAG compliance checking
    - **Import Validation**: eslint-plugin-import with TypeScript resolver
    - **Code Style**: eslint-plugin-prettier for formatting integration
    - **React Hooks**: eslint-plugin-react-hooks for hooks rules enforcement
    - **React Refresh**: eslint-plugin-react-refresh for HMR compatibility
  - **Linting Results**:
    - **Total Issues**: 371 problems found (301 errors, 70 warnings)
    - **Auto-fixable**: 157 errors/warnings can be fixed with `npm run lint` (--fix flag)
    - **Common Issues Found**:
      - **Console Statements** (70 warnings): Unexpected console.log/error calls (no-console rule)
      - **Unused Variables** (many errors): Imports and variables defined but never used (@typescript-eslint/no-unused-vars)
      - **Accessibility** (errors): Missing href on anchor tags, invalid links (jsx-a11y/anchor-is-valid)
      - **Type Safety** (errors): Use of String instead of string, wrapper object types (@typescript-eslint/no-wrapper-object-types)
      - **React Issues**: Missing display names, unescaped entities in JSX (react/display-name, react/no-unescaped-entities)
      - **Import Resolution** (errors): Unable to resolve module paths in some files (import/no-unresolved)
  - **NPM Scripts Available**:
    - `npm run lint:check`: Check for linting issues without fixing (reports only)
    - `npm run lint`: Auto-fix fixable issues with --fix flag
    - `npm run lint:modules:check`: Check only src/modules directory
    - `npm run lint:modules`: Auto-fix only src/modules directory
  - **ESLint Rules Configured**:
    - `no-console: "warn"`: Warns on console usage (should use logger)
    - `react/button-has-type: "error"`: Requires explicit button type attribute
    - `react/react-in-jsx-scope: "off"`: Disabled (React 17+ JSX transform)
    - `react-refresh/only-export-components: "warn"`: Enforces HMR best practices
    - `@typescript-eslint/no-explicit-any: "off"`: Allows any type usage
  - **Files Ignored**: vite.config.mts, vite-env.d.ts, build/, public/ directories
  - **Key Observations**:
    - Linting infrastructure fully functional and comprehensive
    - Significant code quality issues present in existing codebase (371 problems)
    - Many auto-fixable issues available for cleanup (157 fixable)
    - Console statements used extensively (should be replaced with proper logging)
    - Accessibility issues need attention (missing hrefs, invalid anchor usage)
    - TypeScript strict typing could be improved (unused imports, wrapper types)
    - Existing code has linting debt that should be addressed incrementally
  - **Recommendations**:
    - Run `npm run lint` to auto-fix 157 issues before contributions
    - Address console.log statements with proper logging framework
    - Fix accessibility issues for WCAG compliance
    - Remove unused imports and variables for cleaner code
    - Consider enabling stricter TypeScript rules (@typescript-eslint/no-explicit-any)
- [x] Check for code formatting configuration (Prettier, ESLint) and run formatting checks
  - **Completed**: Code formatting infrastructure identified and verified for frontend
  - **Frontend Formatting Configuration**:
    - **Prettier**: v3.7.4 configured with `.prettierrc` file
    - **Configuration File**: `ui/.prettierrc`
    - **Format Settings**:
      - `singleQuote: false` (use double quotes)
      - `printWidth: 120` (max line length)
      - `semi: true` (require semicolons)
      - `trailingComma: "es5"` (trailing commas where valid in ES5)
      - `endOfLine: "lf"` (Unix line endings)
    - **NPM Scripts**:
      - `npm run format:check`: Check formatting without modifying files
      - `npm run format`: Auto-fix formatting issues with --write flag
      - `npm run format:modules:check`: Check only src/modules directory
      - `npm run format:modules`: Auto-fix only src/modules directory
  - **ESLint + Prettier Integration**:
    - **Plugin**: eslint-plugin-prettier v5.5.4 integrated in eslint.config.js
    - **Config**: eslint-config-prettier v10.1.8 (disables conflicting ESLint rules)
    - **Integration**: Prettier rules enforced through ESLint via recommended config
    - **Benefit**: Single command (`npm run lint`) checks both code quality and formatting
  - **Formatting Check Results**:
    - **Command used**: `cd ui && npm run format:check`
    - **Issues Found**: 13 files with formatting violations
    - **Exit Code**: 1 (formatting issues detected)
    - **Files with Issues**:
      - src/domain/Jobs/Details.tsx
      - src/domain/Modules/Create.tsx
      - src/domain/Settings/AddVCS.tsx
      - src/domain/Settings/CreateEditCollection.tsx
      - src/domain/Settings/EditTeam.tsx
      - src/domain/Settings/TeamPermissions.css
      - src/domain/Settings/TeamPermissions.tsx
      - src/domain/Settings/VariableCollections.tsx
      - src/domain/Settings/VCS.tsx
      - src/domain/Workspaces/Create.tsx
      - src/domain/Workspaces/Details.tsx
      - src/domain/Workspaces/Import.tsx
      - src/domain/Workspaces/Settings/General.tsx
  - **Backend Formatting Configuration**:
    - **Finding**: No Java code formatter configured (no Spotless, Checkstyle, or Google Java Format)
    - **Maven POM**: Only JaCoCo (coverage) and SonarCloud plugins configured
    - **EditorConfig**: No root .editorconfig file for cross-editor consistency
    - **Implication**: Java code formatting relies on developer IDE settings (not enforced)
  - **Key Observations**:
    - Frontend has comprehensive formatting infrastructure (Prettier + ESLint integration)
    - 13 files need formatting fixes (can be auto-fixed with `npm run format`)
    - Backend lacks automated code formatting enforcement
    - No CI/CD formatting checks configured (only linting in workflows)
  - **Recommendations**:
    - Run `npm run format` to auto-fix 13 frontend formatting issues before contributions
    - Consider adding Prettier format check to CI/CD workflow (ui pull_request workflow)
    - Consider adding Java formatter (Spotless or Checkstyle) to backend for consistency
    - Add .editorconfig to project root for cross-language editor consistency
- [x] Identify continuous integration configuration (.github/workflows, .gitlab-ci.yml) to understand CI/CD testing
  - **Completed**: Comprehensive CI/CD configuration identified in GitHub Actions
  - **CI Platform**: GitHub Actions (no GitLab CI configuration found)
  - **Workflow Files**:
    - `.github/workflows/pull_request.yml`: Backend build and testing workflow
    - `.github/workflows/pull_request_ui.yml`: Frontend build, linting, and formatting workflow
    - `.github/workflows/release.yml`: Release workflow for Docker image publishing

  - **Backend CI Workflow** (pull_request.yml):
    - **Triggers**: Push to main branch, pull request events (opened, synchronize, reopened)
    - **Jobs**:
      - `build-jammy`: Standard Ubuntu build with Java 25 (Liberica distribution)
      - `build-alpaquita`: Alpaquita Linux build (only on main branch pushes)
    - **Java Setup**: JDK 25 (Liberica distribution)
    - **Build Command**: `mvn -B verify --file pom.xml` (includes tests via Maven verify phase)
    - **Testing**: All backend tests executed during verify phase (91 tests across 3 modules)
    - **Code Quality**: SonarCloud integration with sonar-maven-plugin for code analysis
    - **Cache Strategy**: Maven packages (~/.m2) and SonarCloud packages cached for performance
    - **Fork Handling**: Different build steps for fork PRs (clean install only) vs repository PRs (verify + SonarCloud)
    - **Environment Variables**: USER_NAME, ACCESS_TOKEN, SONAR_TOKEN, GITHUB_TOKEN for authentication
    - **Shallow Clones Disabled**: fetch-depth: 0 for better SonarCloud analysis accuracy

  - **Frontend CI Workflow** (pull_request_ui.yml):
    - **Triggers**: Push to main, pull requests with changes in `ui/**` directory (path filtering)
    - **Node Version**: 22.x (via matrix strategy for future multi-version support)
    - **Working Directory**: ./ui (all commands run in ui subdirectory)
    - **Steps**:
      1. **Dependency Installation**: `yarn install --frozen-lockfile` (ensures reproducible builds)
      2. **Linting**: `yarn lint:modules:check` (checks src/modules directory only)
      3. **Formatting**: `yarn format:modules:check` (checks Prettier formatting compliance)
      4. **Build**: `npm run build --if-present` (creates production build)
    - **Environment**: CI=false to allow warnings during build
    - **Cache**: npm cache via actions/setup-node with cache-dependency-path: ui/package.json
    - **Testing Gap**: No `npm test` step (frontend tests not executed in CI/CD)

  - **Release Workflow** (release.yml):
    - **Trigger**: GitHub release created event
    - **Matrix Strategy**: 3 OS variants (jammy, jammy-arm, alpaquita)
    - **Runners**: ubuntu-24.04 (jammy/alpaquita), ubuntu-24.04-arm (jammy-arm)
    - **Steps**:
      1. Build UI Docker images (jammy and jammy-arm only)
      2. Update POM version to release tag
      3. Build backend Spring Boot images with Maven (tests skipped: -Dmaven.test.skip=true)
      4. Tag and push images to Docker Hub (azbuilder organization)
      5. Merge multi-platform images (amd64 + arm64) using docker buildx
      6. Clean up temporary ARM-tagged images from Docker Hub
    - **Image Naming**: azbuilder/api-server, azbuilder/executor, azbuilder/open-registry, azbuilder/terrakube-ui
    - **Version Tagging**: Both version tag (e.g., 2.0.0) and latest tag applied
    - **Testing in Release**: Tests skipped for release builds (prioritizes build speed)

  - **CI/CD Testing Summary**:
    - **Backend Testing**: ✅ Comprehensive (91 tests run on every PR via mvn verify)
    - **Frontend Testing**: ❌ Gap identified (tests exist but not run in CI/CD)
    - **Linting**: ✅ Frontend linting enforced (371 issues currently in codebase)
    - **Formatting**: ✅ Frontend formatting enforced (13 files with violations)
    - **Code Quality**: ✅ SonarCloud integration for backend code analysis
    - **Build Validation**: ✅ Both frontend and backend builds validated
    - **Release Testing**: ❌ Tests skipped in release workflow for speed

  - **Quality Gates Enforced in CI**:
    - Backend: Build + Test + SonarCloud analysis (for repository PRs)
    - Frontend: Linting + Formatting + Build (tests missing)

  - **CI/CD Optimization Opportunities**:
    - Add `npm test -- --watchAll=false` to frontend CI workflow
    - Consider running backend tests in release workflow (or separate pre-release test job)
    - Add code coverage reporting to frontend CI
    - Consider adding performance testing or E2E tests to CI pipeline

  - **Key Observations**:
    - Backend has robust CI testing pipeline with quality gates
    - Frontend CI focuses on code style/format, missing actual test execution
    - Fork PRs have reduced CI (no SonarCloud) to protect secrets
    - Cache strategy optimizes build times (Maven + npm dependencies)
    - Multi-platform support (amd64 + arm64) in release pipeline
    - Release workflow prioritizes speed over testing (tests skipped)
- [x] Document the testing strategy in testing-guide.md in Auto Run Docs including how to run tests and write new ones
  - **Completed**: Comprehensive testing guide created with 600+ lines covering all testing infrastructure
  - **File Location**: `/Auto Run Docs/testing-guide.md`
  - **Sections Included**:
    - Quick Start: Commands to run frontend and backend tests immediately
    - Frontend Testing: Jest/React Testing Library setup, patterns, and examples
    - Backend Testing: JUnit/Mockito/Spring Test patterns with unit and integration test examples
    - Integration Testing: H2 database config, WireMock setup, authentication patterns
    - API Testing: Thunder Client collections documentation (manual E2E testing)
    - CI/CD Testing: GitHub Actions workflows and current testing enforcement
    - Quality Gates: Pre-submission checklist with all required commands
    - Writing New Tests: Complete templates for frontend and backend tests
    - Best Practices: Testing principles, patterns, and coverage guidelines
    - Troubleshooting: Common issues and solutions
  - **Key Features**:
    - Complete command reference for running all test types
    - Code templates for unit tests, component tests, and integration tests
    - Detailed explanation of testing patterns found in codebase analysis
    - Pre-submission quality gates checklist with exact commands
    - Identification of testing gaps (frontend tests not in CI, no E2E browser tests)
    - Coverage metrics and quality standards documentation
  - **Test Execution Coverage**:
    - Frontend: Jest 30.2.0, 17 existing tests, 98%+ coverage
    - Backend: JUnit 5, 91 tests across 3 modules, all passing
    - Integration: REST Assured API tests with H2 database
    - Manual API Testing: Thunder Client with 199 requests
  - **Documentation Quality**:
    - Table of contents for easy navigation
    - Practical examples with real code snippets
    - Links to external documentation resources
    - Clear separation of frontend vs backend practices
    - Troubleshooting section for common issues
- [x] Create a checklist of quality gates to run before submitting contributions (tests, linting, formatting)
  - **Completed**: Comprehensive quality gates checklist created in `quality-gates-checklist.md`
  - **File Location**: `/Auto Run Docs/quality-gates-checklist.md`
  - **Checklist Sections**:
    - Quick Reference: Fast command lookup for frontend/backend validation
    - Phase 1 - Code Quality: Tests, coverage, linting, formatting, build verification
    - Phase 2 - Code Review: Self-review criteria for code changes
    - Phase 3 - Documentation: Code documentation and change description requirements
    - Phase 4 - Git Hygiene: Branch management, commit quality, clean history
    - Phase 5 - Integration Validation: Local integration testing, API testing, database migrations
    - Phase 6 - Performance & Security: Performance considerations, security review, accessibility
    - Phase 7 - CI/CD Preparation: CI/CD compatibility, pre-push validation
    - Quick Validation Scripts: One-command validation for frontend, backend, and full project
    - Troubleshooting: Common quality gate failure solutions
    - Minimum Required Gates: Must-pass gates for PR submission
  - **Frontend Pre-Submission Commands**:
    ```bash
    cd ui
    npm test -- --watchAll=false          # Run all tests
    npm test -- --coverage --watchAll=false  # Generate coverage report
    npm run lint:check                    # Check for linting issues
    npm run lint                          # Auto-fix linting issues
    npm run format:check                  # Check formatting
    npm run format                        # Auto-fix formatting
    npm run build                         # Verify production build
    ```
  - **Backend Pre-Submission Commands**:
    ```bash
    mvn clean test                        # Run all unit tests
    mvn verify                            # Run tests + integration tests
    mvn clean verify                      # Clean build with all tests
    ```
  - **Key Features**:
    - Complete phase-by-phase quality validation workflow
    - One-command validation scripts for quick checks
    - Troubleshooting guide for common failures
    - Minimum required gates clearly identified
    - Integration with existing testing infrastructure
    - Security, performance, and accessibility considerations
    - Git workflow best practices included
  - **Coverage**:
    - 7 quality gate phases covering all aspects of contribution quality
    - 40+ individual checkpoints across all phases
    - Quick reference commands for immediate execution
    - Links to testing-guide.md and other resources
- [ ] Identify any gaps in test coverage that should be addressed when fixing bugs or adding features